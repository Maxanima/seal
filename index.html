<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Magic Seal 2D/3D</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        background: black;
        font-family: sans-serif;
      }

      #ui {
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        z-index: 10;
      }

      button {
        padding: 10px 20px;
        border: none;
        border-radius: 12px;
        background: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
        color: white;
        font-size: 16px;
        cursor: pointer;
        backdrop-filter: blur(12px);
        transition: all 0.3s ease;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
      }

      button:hover {
        background: rgba(255, 255, 255, 0.2);
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
      }

      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="toggleMode">Toggle View</button>
      <button id="addFigure">Add / Reset</button>
    </div>

    <canvas id="canvas2d"></canvas>
    <canvas id="canvas3d"></canvas>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';

      const canvas2d = document.getElementById('canvas2d');
      const ctx = canvas2d.getContext('2d');
      const canvas3d = document.getElementById('canvas3d');

      let width = window.innerWidth;
      let height = window.innerHeight;
      canvas2d.width = canvas3d.width = width;
      canvas2d.height = canvas3d.height = height;

      let figures2D = [];
      const maxFigures = 4;

      const colors = [
        '#ff007f', '#00ffff', '#ffff00', '#ff00ff', '#00ff00', '#ff6600',
        '#66ccff', '#cc33ff', '#33ffcc', '#ff3333', '#3399ff', '#99ff33'
      ];
      const shapes = ['triangle', 'square', 'pentagon', 'hexagon', 'octagon', 'circle', 'star'];

      function getRandomColor() {
        return colors[Math.floor(Math.random() * colors.length)];
      }

      function getRandomShape() {
        return shapes[Math.floor(Math.random() * shapes.length)];
      }

      function getRandomSpeed() {
        return (0.002 + Math.random() * 0.003) * 0.3;
      }

      function getRandomAngle() {
        return Math.random() * 2 * Math.PI;
      }

      function getRandomSize() {
        return 0.4 + Math.random() * 0.5;
      }

      function drawShape(ctx, shape, radius, cx, cy, baseAngle) {
        if (shape === 'circle') {
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.closePath();
          return;
        }

        if (shape === 'star') {
          const spikes = 5;
          const outerRadius = radius;
          const innerRadius = radius * 0.5;
          const step = Math.PI / spikes;
          ctx.beginPath();
          for (let i = 0; i < 2 * spikes; i++) {
            const r = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = baseAngle + i * step;
            const x = cx + r * Math.cos(angle);
            const y = cy + r * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          return;
        }

        const sides = {
          triangle: 3,
          square: 4,
          pentagon: 5,
          hexagon: 6,
          octagon: 8,
        }[shape];

        ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
          const angle = baseAngle + (i / sides) * 2 * Math.PI;
          const x = cx + radius * Math.cos(angle);
          const y = cy + radius * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
      }

      class Figure2D {
        constructor(shape, color, speed, angleOffset, size) {
          this.shape = shape;
          this.color = color;
          this.speed = speed;
          this.angle = angleOffset;
          this.size = size;
        }

        update() {
          this.angle += this.speed;
        }

        draw(ctx) {
          const radius = this.size;
          const cx = width / 2;
          const cy = height / 2;

          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(this.angle);
          ctx.translate(-cx, -cy);

          ctx.strokeStyle = this.color;
          ctx.lineWidth = 6;
          ctx.shadowBlur = 25;
          ctx.shadowColor = this.color;

          drawShape(ctx, this.shape, radius, cx, cy, 0);
          ctx.stroke();
          ctx.restore();
        }
      }

      function animate2D() {
        ctx.clearRect(0, 0, width, height);
        for (let fig of figures2D) {
          fig.update();
          fig.draw(ctx);
        }
        requestAnimationFrame(animate2D);
      }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(70, width / height, 0.1, 1000);
      camera.position.z = 2.8;
      const renderer = new THREE.WebGLRenderer({ canvas: canvas3d, alpha: true, antialias: true });
      renderer.setSize(width, height);

      const group = new THREE.Group();
      scene.add(group);

      function createLineGeometry(shape, radius = 1.0) {
        const points = [];
        if (shape === 'circle') {
          for (let i = 0; i <= 64; i++) {
            const angle = (i / 64) * 2 * Math.PI;
            points.push(new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0));
          }
        } else {
          const sides = {
            triangle: 3,
            square: 4,
            pentagon: 5,
            hexagon: 6,
            octagon: 8,
            star: 10
          }[shape];
          for (let i = 0; i <= sides; i++) {
            const angle = (i / sides) * 2 * Math.PI;
            const r = shape === 'star' ? (i % 2 === 0 ? radius : radius * 0.5) : radius;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            points.push(new THREE.Vector3(x, y, 0));
          }
        }
        return new THREE.BufferGeometry().setFromPoints(points);
      }

      function createShape3D(shape, color) {
        const layers = 5;
        const spacing = 0.015;
        const baseSize = getRandomSize();
        const group3D = new THREE.Group();

        for (let i = 0; i < layers; i++) {
          const geometry = createLineGeometry(shape, baseSize);
          const material = new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.5 });
          const line = new THREE.LineLoop(geometry, material);
          line.position.z = (i - (layers - 1) / 2) * spacing;
          group3D.add(line);
        }

        group3D.rotation.x = getRandomAngle();
        group3D.rotation.y = getRandomAngle();
        group3D.rotation.z = getRandomAngle();
        group3D.userData = {
          rx: getRandomSpeed(),
          ry: getRandomSpeed(),
          rz: getRandomSpeed(),
          pulse: 0
        };
        group.add(group3D);
      }

      function animate3D() {
        group.children.forEach((obj) => {
          obj.rotation.x += obj.userData.rx;
          obj.rotation.y += obj.userData.ry;
          obj.rotation.z += obj.userData.rz;

          obj.userData.pulse += 0.05;
          const pulseOpacity = 0.3 + 0.2 * Math.sin(obj.userData.pulse);
          obj.children.forEach((line) => {
            line.material.opacity = pulseOpacity;
          });
        });
        renderer.render(scene, camera);
        requestAnimationFrame(animate3D);
      }

      let currentMode = '2d';

      document.getElementById('toggleMode').onclick = () => {
        currentMode = currentMode === '2d' ? '3d' : '2d';
        canvas2d.style.display = currentMode === '2d' ? 'block' : 'none';
        canvas3d.style.display = currentMode === '3d' ? 'block' : 'none';
      };

      document.getElementById('addFigure').onclick = () => {
        if (currentMode === '2d') {
          if (figures2D.length >= maxFigures) {
            figures2D = [];
            return;
          }
          const shape = getRandomShape();
          const color = getRandomColor();
          const speed = getRandomSpeed();
          const angleOffset = getRandomAngle();
          const size = getRandomSize() * 100;
          figures2D.push(new Figure2D(shape, color, speed, angleOffset, size));
        } else {
          if (group.children.length >= maxFigures) {
            group.children.forEach(child => {
              child.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) obj.material.dispose();
              });
            });
            group.clear();
            return;
          }
          const shape = getRandomShape();
          const color = getRandomColor();
          createShape3D(shape, color);
        }
      };

      animate2D();
      animate3D();

      window.addEventListener('resize', () => {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas2d.width = canvas3d.width = width;
        canvas2d.height = canvas3d.height = height;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      });

      canvas3d.style.display = 'none';
    </script>
  </body>
</html>
